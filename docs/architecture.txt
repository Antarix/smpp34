smpp34 is designed to be a well behaved OTP application.

This is so that it behaves properly when stacked up and used by
other OTP applications.

Components
==========

smpp34 is made up of a set of components, which have clearly defined
tasks, and communicate with each other via messages.

The components are:

tx -    The PDU transmitter. This is responsible for all OUTBOUND tcp
        communication. It takes in records representing the PDU and then
		packs them into binary before sending them on their merry way 
		on the network.

snum - Generates sequence numbers. It is used by tx to add sequence numbers
       to outgoing PDUs that do not have sequence numbers already.


rx -    The PDU aware receiver. This where all incoming PDUs get delivered
        after being unpacked. rx is protocol aware and is responsible for
		taking some actions on the PDU before delivering them to its owner
		process. Some of the actions taken on PDUs include:

			#enquire_link{}: rx will construct an enquire_link_resp{} pdu
		                     and send to tx for delivery
			#unbind{}: rx will construct an unbind_resp{} pdu and deliver
					   to tx for network delivery, then it will die. 
			#unbind_resp{}: die :)

tcprx - The TCP receiver. This is responsible for all INBOUND tcp 
        communication. It takes in binary PDUs from the network and
		unpacks them into erlang records representing the PDU. Then
		delivers them the rx module which owns it.

esme - This is the process that actually orchestrates the functioning of
	     the other components. More accurately, it starts the creation process
		 and initiates a normal teardown when the need arises. 


The relationship can be represented like:

+ esme
    + tx
	    + snum
    + rx
	    + tcprx

process | source | data type
=============================
esme    | rx     | #pdu{}
tx      | snum   | sequence_numbers
tx      | rx     | #pdu{}
tx      | esme   | #pdu{}
rx      | tcprx  | #pdu{}
tcprx   | NETWORK| binary pdu
snum    |        |

process | sink   |  data type
=============================
esme    | tx     |  #pdu{}
tx      | NETWORK| binary pdu
rx      | tx     |  #pdu{}
rx      | esme   |  #pdu{}
tcprx   | rx     |  #pdu{}
snum    | tx     |  sequence_numbers

Supervision Tree
================

Because smpp34 wants to be a properly behaved OTP citizen, it has a well defined
supervision tree. Every component described above, apart from the smpp34
gen_server is part of that supervision tree. The reason why the smpp34
gen_server is not part of that tree is because it is mean to be used
interactively, so supervising it does not make sense.

The tree is described next.

+ smpp34_app
    + smpp34_sup [one_for_one]
		+ smpp34_tx_sup [simple_one_for_one]
			+ smpp34_tx [temporary]
		+ smpp34_rx_sup [simple_one_for_one]
			+ smpp34_rx [temporary]
		+ smpp34_tcprx_sup [simple_one_for_one]
			+ smpp34_tcprx   [temporary]
		+ smpp34_snum_sup  [simple_one_for_one]
			+ smpp34_snum  [temporary]


In the illustration shown, the smpp34_app is the application callback which
starts the smpp34_sup the top-level supervisor (a one_for_one supervisor).

smpp34_sup starts all the other supervisors:
	smpp34_tx_sup
	smpp34_rx_sup
	smpp34_tcprx_sup
	smpp34_snum_sup

These next level of supervisors are all simple_one_for_one supervisors.

Once all these are started, the smpp34 library is ready to be used. Using
the library then just involves asking the second level supervisors to 
start an instance of their child_spec. This is exactly what the esme
process does.


Startup Sequence
================

The startup sequence is as follows:

esme -> tx [-> snum] -> rx [-> tcprx]



Monitoring Relationship
=======================

esme -> tx, rx
     tx -> esme, snum
	    snum -> tx
	 rx -> esme, tx, tcprx
	    tcprx -> rx


The Kiss Of Death
=================

On of the reasons for structuring the monitoring relationship this way, is to
have an easy clear and preditable set of actions when components begin to die.

The core principle is to make certain modules responsible for certain cleanup
actions, and then ensure that the monitoring relationship enables this approach.

The following are the possible scenarios.

1.









