smpp34 is designed to be a well behaved OTP application.

This is so that it behaves properly when stacked up and used by
other OTP applications.

Components
==========

smpp34 is made up of a set of components, which have clearly defined
tasks, and communicate with each other via messages.

The components are:

tx -    The PDU transmitter. This is responsible for all OUTBOUND tcp
        communication. It takes in records representing the PDU and then
		packs them into binary before sending them on their merry way 
		on the network.

snum - Generates sequence numbers. It is used by tx to add sequence numbers
       to outgoing PDUs that do not have sequence numbers already.


rx -    The PDU aware receiver. This where all incoming PDUs get delivered
        after being unpacked. rx is protocol aware and is responsible for
		taking some actions on the PDU before delivering them to its owner
		process. Some of the actions taken on PDUs include:

			#enquire_link{}: rx will construct an enquire_link_resp{} pdu
		                     and send to tx for delivery
			#unbind{}: rx will construct an unbind_resp{} pdu and deliver
					   to tx for network delivery, then it will die. 
			#unbind_resp{}: die :)

tcprx - The TCP receiver. This is responsible for all INBOUND tcp 
        communication. It takes in binary PDUs from the network and
		unpacks them into erlang records representing the PDU. Then
		delivers them the rx module which owns it.

esme - This is the process that actually orchestrates the functioning of
	     the other components. More accurately, it starts the creation process
		 and initiates a normal teardown when the need arises. 


The relationship can be represented like:

+ esme
    + tx
	    + snum
    + rx
	    + tcprx

The table below shows the various processes and the data flows and
transformations that take place between them

process | input process | input datatype | output process | output datatype
===========================================================================
esme    | rx            | #pdu{}         | USERSPACE      | #pdu{}
esme    | USERSPACE     | #pdu{}         | tx             | #pdu{}
tx      | snum          | sequence_nums  |                |
tx      | esme          | #pdu{}         | NETWORK        | <<pdu>>
tx      | rx            | #pdu{}         | NETWORK        | <<pdu>>
rx      | tcprx         | #pdu{}         | esme           | #pdu{}
rx      | tcprx         | #pdu{}         | tx             | #pdu{}
tcprx   | NETWORK       | <<pdu>>        | rx             | #pdu{}
snum    |               |                | tx             | sequence_nums


Supervision Tree
================

Because smpp34 wants to be a properly behaved OTP citizen, it has a well defined
supervision tree. Every component described above, apart from the smpp34
gen_server is part of that supervision tree. The reason why the smpp34
gen_server is not part of that tree is because it is mean to be used
interactively, so supervising it does not make sense.

The tree is described next.

+ smpp34_app
    + smpp34_sup [one_for_one]
		+ smpp34_tx_sup [simple_one_for_one]
			+ smpp34_tx [temporary]
		+ smpp34_rx_sup [simple_one_for_one]
			+ smpp34_rx [temporary]
		+ smpp34_tcprx_sup [simple_one_for_one]
			+ smpp34_tcprx   [temporary]
		+ smpp34_snum_sup  [simple_one_for_one]
			+ smpp34_snum  [temporary]


In the illustration shown, the smpp34_app is the application callback which
starts the smpp34_sup the top-level supervisor (a one_for_one supervisor).

smpp34_sup starts all the other supervisors:
	smpp34_tx_sup
	smpp34_rx_sup
	smpp34_tcprx_sup
	smpp34_snum_sup

These next level of supervisors are all simple_one_for_one supervisors.

Once all these are started, the smpp34 library is ready to be used. Using
the library then just involves asking the second level supervisors to 
start an instance of their child_spec. This is exactly what the esme
process does.


Startup Sequence
================

The startup sequence respects the process relationship previously shown 

+ esme
    + tx
	    + snum
    + rx
	    + tcprx

The esme will start the tx, which in turn starts it's private snum.
Then the esme will start the rx, which in turn starts it's private tcprx.

During startup, any errors encountered, will be reported all the way back to the
esme.


Monitoring Relationship
=======================

The proper functioning of the various processes depends on knowing when any
other process in its pipeline has died, so the process in question can take
appropriate action. 

The result of this is the following monitoring relationship. The arrow direction
shows points to what is being monitored from the "what" that is doing the
monitoring.

esme -> tx, rx
     tx -> esme, snum
	    snum -> tx
	 rx -> esme, tx, tcprx
	    tcprx -> rx


The Kiss Of Death
=================

Combining the supervision tree and the monitoring relationships results in a
precise and intricate relationship between the various modules and their
supervisors.

These relationships actually translate into a few definite ways in which death
can occur. smpp34 teardown is designed around these explicity and specific
instances.

In addition to this, each module is primarily responsible for specific cleanup
actions and the particular cleanup action depends on what is triggering that
particular death.

The details are as follows:

1. tcprx
=========
	a. supervisor shutdown
		- terminate will be called with reason 'shutdown'
		- nothing extra, just die
	b. esme initiated shutdown
		- stop with reason normal
	c. rx dies
		- stop with reason normal
	d. internal exception
		- allow reason to bubble and be logged
	e. socket closed by remote
	    - stop with reason 'tcp_closed'
	f. socket error 
	    - stop with reason 'tcp_error'

2. snum
=======
	a. supervisor shutdown
		- terminate will be called with reason 'shutdown'
		- nothing extra, just die
	b. esme initiated shutdown
		- stop with reason normal
	c. tx dies
		- stop with reason normal
	d. internal exception
		- allow reason to bubble and be logged

3. rx
=======
	a. supervisor shutdown
		- terminate will be called with reason 'shutdown'
		- nothing extra, just die
	b. esme initiated shutdown
		- stop with reason normal
	c. esme dies
	    - stop with reason normal
	c. tx dies
		- stop with reason normal
	d. tcprx dies
		- stop with reason {tcprx, Reason}
		- this will bubble up to esme for possible informing of userspace
	e. SMSC sends #unbind{}
		- we're being asked to unbind
		- stop with reason 'unbind'
	f. SMSC sends #unbind_response{}
		- we're being given a response to a previous 'unbind' we sent
		- stop with reason 'unbind_response'
	e. internal exception
	  	- allow reason to bubble and be logged 

4. tx
=======
	a. supervisor shutdown
		- terminate will be called with reason 'shutdown'
		- send #unbind{} to SMSC
	b. esme initiated shutdown
		- send #unbind{} to SMSC
		- stop with reason normal
	c. esme dies
		- send #unbind{} to SMSC
	    - stop with reason normal
	d. snum dies
		- send #unbind{} to SMSC
		- stop with reason {snum, Reason}
		- this will bubble up to esme for possible informing of userspace
	e. internal exception
		- send #unbind{} to SMSC
	  	- allow reason to bubble and be logged 

5. esme
=======
	a. supervisor shutdown
		- terminate will be called with reason 'shutdown'
		- nothing extra, just die
	b. esme initiated shutdown
		- stop with reason normal
	c. rx dies
		- close tx
		- change state to closed
	d. tx dies
		- close rx
		- change state to closed
	d. internal exception
		- allow reason to bubble and be logged
