gen_esme34 is an asynchronous interface that is designed to be used when 
there is a need to fit into an OTP supervision tree.

gen_esme34 takes esme_core and builds infrastructure around it, exposing a 
gen_server type framework and behaviour that makes building ESMEs a well 
defined task.

This document assumes a basic understanding of the SMPP procotocol, the Erlang
programming language and the OTP framework.

Integration with gen_server
----------------------------

The terrible ASCII art below shows the core interaction:

      -----params---->      --request message->     ---params-->

GEN_ESME34_FUNC - GEN_SERVER_FUNC - GEN_SERVER_CALLBACK - GEN_ESME34_CALLBACK

      <----response---      <-response message-     <--response--               


The description of the diagramatic interaction follows.

When a caller calls one of the gen_esme34 api functions for instance 
gen_esme34:call/2 with a set of parameters, gen_esme34:call/2 is implemented
to directly call gen_server:cast/2 with the very same parameters that it was
called with. The gen_server infrastructure will generate a message and send
to the gen_server process referenced by the ServerRef parameter in the call.

That message will be recieved by the gen_server in its handle_call/3 callback.

At this point, the gen_server just wraps the received parameters and calls
gen_esme34:handle_call/3 as a function passing it the parameters it has just
received.

Any responses are sent back along this path.


gen_esme34 api summary
-----------------------
Since gen_esme34 is designed to be used in any place a gen_server would make
logical sense, it implements _all_ the functions and callbacks that a normal
gen_server implements (with a few differences) and then adds a few functions
and callbacks that are specific to gen_esme34.

The table below gives a summary:

Function                Callback
________________________________

start                   init[1]
start_link              init[1]
call                    handle_call
multicall               handle_call
cast                    handle_cast
abcast                  handle_cast
reply
ping[2]
transmit_pdu[2]         handle_tx[3]
                        handle_info
                        handle_rx[3]


[1] - Callback is also present in gen_server but the usage is changed
      in gen_esme34
[2] - Function call is unique to gen_esme34
[3] - Callback is unique to gen_esme34


The rest of this document throws more light on the gen_esme34 specific side
of things.

Binding to an SMSC
------------------

The first step in building an ESME is normally to bind to the SMSC. 

When gen_esme34:start or gen_esme34:start_link is called, gen_esme34 will
attempt to establish a connection to the SMSC and send a bind pdu to the SMSC
for you. The host address, port and the bind pdu have to be specified in the
return tuple of the init/1 callback. A proper return value from init/1 will
look like:

    {ok, {SmscAddr, SmscPort, BindPdu}, State}.

The BindPdu is a pdu body from the smpp34pdu library, while the State is the
internal gen_esme34 state (same as a gen_server state).

gen_esme34 takes this tuple and makes the connection to the SMSC returning
the Pid of the gen_esme34 if successfull or an error and reason if it fails.

Once successfull, the gen_esme34 is considered up and running.


Receiving Pdus
--------------

When ever the SMSC sends us a pdu that needs to be delivered to userspace,
gen_esme34 calls the handle_rx/2 callback. 

The handle_rx callback accepts the Pdu as the first parameter and the module
state as the second parameter. The Pdu can be then accessed for what ever work
is required and the callback reply returned.


Transmitting Pdus
-----------------

There are three different ways to transmit PDUs.

1. Synchronous (From Userspace only via transmit_pdu/2,3
2. Asynchronous (From Userspace and within gen_esme34 callback, via
                 async_transmit_pdu/2,3
3. Via {tx,,} tuple (From within gen_esme34 callback

The transmit functions are:

   - transmit_pdu(ServerRef, Pdu)
   - transmit_pdu(ServerRef, Pdu, Extra)
   - async_transmit_pdu(ServerRef, Pdu)
   - async_transmit_pdu(ServerRef, Pdu, Extra)
   
The {tx,,} tuple is defined further below.

ServerRef is the gen_esme34 server reference returned from start or start_link.
Extra is the extra parameter passed to handle_tx. Note that in transmit_pdu/2
and async_transmit_pdu/2 where the extra parameter is not supplied, 
the atom undefined, is delivered to handle_tx.



Synchronous Tranmission - transmit_pdu/2,3
------------------------------------------

The simplest way to transmit a PDU is from Userspace by calling
gen_esme34:transmit_pdu/2 or its close cousin gen_esme34:transmit_pdu/3.

transmit_pdu/2 takes the gen_esme34 server reference (either pid or registered
name) as well as the PDU to transmit. It proceeds to transmit the PDU and
only returns to the call _after_ the tranmission has been attempted.

The results of the transmission are delivered to the handle_tx/3 callback.
See below.

An important point to note about the synchronous API is that it is limited by
the effective throughput b/w gen_esme34 and the SMSC. That is, transmit_pdu
will never work faster than the lowest time it takes to send a PDU to the SMSC.

As such the synchronous api will never overrun the gen_esme34, no matter how
slow or throttled the connection to the SMSC is.

Another point to note is that the synchronous api can ONLY be called from
Userspace. Transmission from within the gen_esme34 callback has to be done
using any of the other two methods.

Asynchronous Transmission - async_transmit_pdu/2,3
--------------------------------------------------

The async_transmit_pdu/2,3 functions exist to bypass the limitations of the 
transmit_pdu/2,3 functions, namely:

1. Limited by througput on the wire
2. Can only be called from Userspace

To this end, the asynchronous api is implemented by gen_server:cast, rather 
than gen_server:call for the synchronous api. The parameters are exactly the
same as with transmit_pdu/2,3.

The problem now becomes that it is possible to overrun the gen_esme34 mailbox
if the sender transmits much faster than the effective througput on the wire
between gen_esme34 and SMSC. This can lead to the gen_esme34 crashing when
the SMSC throttles it or there is a sudden burst of messages.

To help manage this, the gen_esme34 introduces an option during create time:
  - max_async_transmit

This option when set, limits the asynchronous api to have at most 
max_async_transmit outstanding PDUs yet to be transmitted. When this condition
occurs, a warning message is sent to handle_tx/3 to notify of this condition.

This warning message is:
    {warning, transmit_overload}

It is delivered as the first parameter of the handle_tx/3 callback. Once 
received, the implementor SHOULD take steps to throttle its sending. The best
way being to introduce a back-off timer of some sort and try again when the
timer expires.  Remember also that an 'Extra' parameter is passed as the second
paramter to the handle_tx/3 function, which should be used to uniquely identify
each PDU expecially important in this case.


Transmitting Via {tx,,} tuple
-----------------------------
Apart from init/1, terminate/2 and code_change/3, all other callbacks implement
the {tx,} tuple response. This response spec initiates a transmit of the PDU
defined in the PDU spec, from within gen_esme34 itself as opposed to 
transmitting from user space.  This is typically used to send response PDUs

handle_call/3, handle_cast/2, handle_info/2, handle_rx/2 and handle_tx/3 all
support the {tx,,} tuple response spec.

The 'tx' tuple looks like:

    {tx, PduSpec, State}

This reply tuple triggers gen_esme34 to transmit the PduSpec to the SMSC.

The PduSpec can be:

    - #pdu{}
    - {#pdu{}, Extra}
    - [PduSpec]
    - []

The parameter 'Extra' is passed 'as-is' to handle_tx in the 'Extra' parameter. 
See further below for more information.

*** Note that for handle_call/3, if the 'tx' tuple is returned, instead of a 
reply tuple, the gen_esme34 will have to explicitly call gen_esme34:reply/2



Transmitted Pdus
----------------

When a PDU is sent to the SMSC either successfully or the sending failed, this
reply is contained in a tuple and can be any of the following:

    - {ok, SmppSequenceNumber} :
            PDU tranmitted successfully
    - {error, Reason}
            Error occurred with reason 'Reason' when transmitting the PDU
    - {warning, transmit_overload}
            max_async_transmit limit exceeded. 

This status reason is delivered to handle_tx/3, along with the 'Extra' 
parameter and the gen_esme34 state.

The Extra parameter is typically used to identify the PDU at the time of 
sending (either when the {tx,_,_} tuple is returned from handle_rx/2 or
as we shall soon see, when calling transmit_pdu. This should be carry at
least a transaction id uniquely associated with the PDU.

If no extra parameter was specified, it will be the atom 'undefined'


Instrospection: Ping/1
----------------------

One interesting function provided by gen_esme34 is the ping/1 function.

This just provides a way to query the gen_esme34 and see what's going on
inside it. It returns a proplist that gives top secret insider info on
what's happening inside the gen_esme34.

Enquire_Link[_Resp]
-------------------

Enquire_Link and Enquire_Link_Resp pdus are handled by esme_core and never 
leak across the abstraction boundary. There is no need to worry about it as
esme_core will automagically respond with the proper response.

Unbind[_Resp]
-------------
When the SMSC sends an Unbind pdu, esme_core will honor this by sending the
unbind response and disconnecting. The gen_esme34 will die with the proper
reason. If an unbind response is recieved due to an unbind we sent earlier,
the same thing happens.
